h2. 레일스의 레이아웃과 렌더링

본 가이드에서는 액션 컨트롤러와 액션 뷰의 기본 레이아웃 기능을 다루게 됩니다. 본 가이드를 참조하여 다음을 구현할 수 있습니다.:

* 레일스에 내장된 다양한 렌더일 메소드 사용하기
* 다중 컨텐츠 섹션과 함께 레이아웃 구성하기
* partial 템플릿을 이용하여 뷰 템플릿의 중복 코드 없애기
* 중첩레이아웃(서브템플릿) 사용하기 

endprologue.

h3(#Overview-How-the-Pieces-Fit-Together). 개요 : 컨텐츠 조각들을 합치는 방법

이 가이드는 MVC 삼각구도에서 컨트롤러와 뷰 사이의 상호작용에 촛점을 맞추어 설명합니다. 알다시피, 컨트롤러는, 보통 많은 양의 코드가 모델에 집중되기는 하지만, 레일스에서 요청을 처리하는 전체 과정을 지휘하는 역할을 합니다. 그러나 유저에게 응답을 보낼 때, 컨트롤러는 뷰로 권한을 이양하게 됩니다. 이러한 과정을 본 가이드에서 다루게 됩니다. 

대략적으로 이러한 과정은 응답으로 무엇을 보낼 것이고 응답을 만들기 위해 어떤 메소드를 호출할 것인가를 결정하게 됩니다. 응답으로 전체 뷰를 만들 경우, 레일스는 어떤 추가적인 작업을 수행하여 하나의 레이아웃으로 뷰를 감싸고 가능하면 @partial@ 를 이용하게 됩니다. 이 모든 것을 본 가이드에게 알게 될 것입니다. 

h3(#Creating-Responses). 응답 만들기

컨트롤러의 입장에서 볼 때 HTTP 응답을 보내는 방법으로 세가지가 있습니다:

* +render+ 을 호출하여 브라우져로 완전한 응답을 보냅니다.
* +redirect_to+ 를 호출하여 브라우져로 HTTP 리디렉트 상태코드를 보냅니다.
* +head+ 를 호출하여 브라우져로 보내게 될 HTTP 헤더만으로 구성된 응답을 만들어 줍니다.

차례대로 이 메소드에 대해서 다룰 것이지만 무엇보다도, 컨트롤러가 응답을 만들기 위해서 할 수 있는 가장 손쉬운 것은 아무것도 없다는 것입니다.

h4(#Rendering-by-Default-Convention-Over-Configuration-in-Action). 디폴트 상태로 렌더링하기 : 액션에서의 규칙

알다시피 레일스는 "convention over configuration"(설정보다는 규칙)을 내세우고 있습니다. 디폴트 렌더링이 대표적인 예가 될 수 있습니다. 디폴트로 레일스의 컨트롤러는 라우트에 해당하는 이름으로 뷰를 렌더링합니다. 예를 들면, +BooksController+ 클래스가 다음과 같을 경우:

<ruby>
class BooksController < ApplicationController
end
</ruby>

라우트 파일에서 리소스 라우팅이 다음과 같고:

<ruby>
resources :books
</ruby>

+app/vews/books/index.html.erb+ 뷰 파일이 다음과 같다면:

<ruby>
<h1>Books are coming soon!</h1>
</ruby>

+/books+ 로 이동할 경우 레일스는 자동으로 +app/views/books/index.html.erb+ 를 렌더링해서 스크린상에 “Books are coming soon!”이라는 문구를 보여 줄 것입니다.

그러나 이 문구가 보이는 스크린은 그렇게 유용한 정보가 없어서 +Book+ 모델을 만들어서 +BooksController+ 에 index 액션을 추가해 보도록 하겠습니다:

<ruby>
class BooksController < ApplicationController
  def index
    @books = Book.all
  end
end
</ruby>

여기서 주목할 것은 CoC(설정보다는 규칙)원칙에 따라 @index@ 액션 마지막에 render 메소드가 명시되어 있지 않다는 것 입니다. 즉, 컨트롤러 액션의 마지막에 명시적으로 무언가를 render 하지 않는다면 레일스는 자동으로 컨트롤러의 뷰 경로상의 +action_name.html.erb+ 템플릿을 찾아 렌더링할 것입니다. 따라서 이 경우에, 레일스는 +app/views/books/index.html.erb+ 파일을 렌더링하게 될 것입니다.

만약 현재의 뷰에서 모든 책의 특징을 디스플레이하고자 한다면, ERB 템플릿을 다음과 같이 작성할 수 있습니다:

<ruby>
<h1>Listing Books</h1>

<table>
  <tr>
    <th>Title</th>
    <th>Summary</th>
    <th></th>
    <th></th>
    <th></th>
  </tr>

<% @books.each do |book| %>
  <tr>
    <td><%= book.title %></td>
    <td><%= book.content %></td>
    <td><%= link_to "Show", book %></td>
    <td><%= link_to "Edit", edit_book_path(book) %></td>
    <td><%= link_to "Remove", book, :confirm => "Are you sure?", :method => :delete %></td>
  </tr>
<% end %>
</table>

<br />

<%= link_to "New book", new_book_path %>
</ruby>

NOTE: 실제적인 렌더링 작업은 +ActionsView::TemplateHandlers+ 가 하게 됩니다. 본 가이드에서는 이 과정을 깊숙이 다루지 않을 것이지만, 뷰 파일의 확장자에 따라 어떤 템플릿 핸들러가 작업을 하게 되는지를 결정하게 된다는 것을 아는 것이 중요합니다. 레일스 2에서는 ERB(루비코드가 임베디드된 HTML)에 대한 표준 확장자는 +.erb+ 이고 Builder(XML 생성기)에 대한 확장자는 +.builder+ 입니다.

h4(#Using-render). +render+ 사용하기

대부분의 경우, +ActionController::Base#render+ 메소드는 브라우져에 보여 줄 어플리케이션의 내용물을 렌더링하는 힘든 작업을 하게 됩니다. 이러한 +render+ 메소드의 작업을 변경하는 방법에는 여러가지가 있습니다. 즉, +render+ 메소드는 레일스 템플릿의 디폴트 뷰, 특정 템플릿, 파일, 또는 인라인 코드를 렌더링할 수 있다는 것입니다. 개발자는 이러한 내용물을 텍스트, JSON, 또는 XML 포맷으로 렌더링할 수 있습니다. 또한 렌더링되는 응답내용물의 포맷이나 HTTP 상태를 명시할 수 있습니다.

TIP: +render+ 호출에 대한 정확한 결과물을 브라우져상에서 보지 않기를 원한다면, +render_to_string+ 를 호출할 수 있습니다. 이 메소드는 +render+와 동일한 옵션을 설정할 수 있지만, 응답내용을 브라우져가 아닌 문자열로 반환한다는 것입니다.

h5(#Rendering-Nothing). 아무것도 렌더링하지 않기

아마도 +render+로 할 수 있는 가장 간단한 것은 아무것도 렌더링하지 않는 것입니다:

<ruby>
render :nothing => true
</ruby>

cURL를 이용해서 응답내용을 본다면, 다음과 같을 것입니다:

<shell>
$ curl -i 127.0.0.1:3000/books
HTTP/1.1 200 OK
Connection: close
Date: Sun, 24 Jan 2010 09:25:18 GMT
Transfer-Encoding: chunked
Content-Type: */*; charset=utf-8
X-Runtime: 0.014297
Set-Cookie: _blog_session=...snip...; path=/; HttpOnly
Cache-Control: no-cache


 $
</shell>

(+Cache-Control+ 라인 이후에 데이터가 없음) 응답내용이 아무 것도 없다는 것을 알 수 있지만 레일스가 응답코드로 200을 설정했기 때문에 요청이 성공적으로 이루어 진 것입니다. 이 응답을 변경하기 위해서는 렌더링시에 +:status+ 옵션을 설정하면 됩니다. 아무 것도 렌더링하지 않는 것은, 브라우저로 보내고자 하는 것이 그저 요청이 완료되었다는 내용 뿐인 AJAX 요청일 경우에 유용합니다.

TIP: +render :nothing+ 대신에, 본 가이드의 나중에 언급될 것이지만, +head+ 메소드를 사용해야 할 것입니다. 이렇게 하면 보다 유연하게 작업을 할 수 있고 단지 HTTP 헤더만을 생성한다는 것을 명시적으로 알 수 있게 됩니다.

h5(#Rendering-an-Actions-View). 액션 뷰 렌더링하기

동일한 템플릿내에서 다른 액션에 해당하는 뷰를 렌더링하고자 한다면, 해당 뷰의 이름으로 +render+ 메소드를 이용할 수 있습니다:

<ruby>
def update
  @book = Book.find(params[:id])
  if @book.update_attributes(params[:book])
    redirect_to(@book)
  else
    render "edit"
  end
end
</ruby>

+update_attributes+ 호출이 실패한다면 이 컨트롤러에 있는 +update+ 액션에 대한 호출은 동일한 컨트롤러 내의 +edit.html.erb+ 템플릿을 렌더링하게 될 것입니다.

개발자의 선호도에 따라, 렌더링할 액션을 명시하기 위해 문자열 대신에 심볼을 사용할 수도 있습니다:

<ruby>
def update
  @book = Book.find(params[:id])
  if @book.update_attributes(params[:book])
    redirect_to(@book)
  else
    render :edit
  end
end
</ruby>

(레일스 3.0 이후부터는 더 이상 필요없게 되었지만,) 명확하게 하기 위해서 +:action+ 옵션을 추가하여 +render 메소드를 이용할 수도 있습니다:

<ruby>
def update
  @book = Book.find(params[:id])
  if @book.update_attributes(params[:book])
    redirect_to(@book)
  else
    render :action => "edit"
  end
end
</ruby>

WARNING: +:action+ 옵션으로 +render+ 메소드를 사용할 경우 레일스 초보자들에게는 혼선을 빚을 수 있습니다. 여기서의 명시된 액션은 렌더링할 뷰를 결정하기 위한 것으므로 레일스가 컨트롤러의 해당 액션에 대한 어떠한 코드도 실행하지 않는다는 것입니다. 따라서 명시된 액션의 뷰에서 필요로하는 인스턴스 변수들은 +render+ 를 호출하기 전에 현재의 액션에서 설정되어야만 한다는 것입니다.

h5. Rendering an Action's Template from Another Controller

What if you want to render a template from an entirely different controller from the one that contains the action code? You can also do that with +render+, which accepts the full path (relative to +app/views+) of the template to render. For example, if you're running code in an +AdminProductsController+ that lives in +app/controllers/admin+, you can render the results of an action to a template in +app/views/products+ this way:

<ruby>
render "products/show"
</ruby>

Rails knows that this view belongs to a different controller because of the embedded slash character in the string. If you want to be explicit, you can use the +:template+ option (which was required on Rails 2.2 and earlier):

<ruby>
render :template => "products/show"
</ruby>

h5. Rendering an Arbitrary File

The +render+ method can also use a view that's entirely outside of your application (perhaps you're sharing views between two Rails applications):

<ruby>
render "/u/apps/warehouse_app/current/app/views/products/show"
</ruby>

Rails determines that this is a file render because of the leading slash character. To be explicit, you can use the +:file+ option (which was required on Rails 2.2 and earlier):

<ruby>
render :file =>
  "/u/apps/warehouse_app/current/app/views/products/show"
</ruby>

The +:file+ option takes an absolute file-system path. Of course, you need to have rights to the view that you're using to render the content.

NOTE: By default, the file is rendered without using the current layout. If you want Rails to put the file into the current layout, you need to add the +:layout => true+ option.

TIP: If you're running Rails on Microsoft Windows, you should use the +:file+ option to render a file, because Windows filenames do not have the same format as Unix filenames.

h5. Wrapping it up

The above three ways of rendering (rendering another template within the controller, rendering a template within another controller and rendering an arbitrary file on the file system) are actually variants of the same action.

In fact, in the BooksController class, inside of the update action where we want to render the edit template if the book does not update successfully, all of the following render calls would all render the +edit.html.erb+ template in the +views/books+ directory:

<ruby>
render :edit
render :action => :edit
render "edit"
render "edit.html.erb"
render :action => "edit"
render :action => "edit.html.erb"
render "books/edit"
render "books/edit.html.erb"
render :template => "books/edit"
render :template => "books/edit.html.erb"
render "/path/to/rails/app/views/books/edit"
render "/path/to/rails/app/views/books/edit.html.erb"
render :file => "/path/to/rails/app/views/books/edit"
render :file => "/path/to/rails/app/views/books/edit.html.erb"
</ruby>

Which one you use is really a matter of style and convention, but the rule of thumb is to use the simplest one that makes sense for the code you are writing.

h5. Using +render+ with +:inline+

The +render+ method can do without a view completely, if you're willing to use the +:inline+ option to supply ERB as part of the method call. This is perfectly valid:

<ruby>
render :inline =>
  "<% products.each do |p| %><p><%= p.name %></p><% end %>"
</ruby>

WARNING: There is seldom any good reason to use this option. Mixing ERB into your controllers defeats the MVC orientation of Rails and will make it harder for other developers to follow the logic of your project. Use a separate erb view instead.

By default, inline rendering uses ERB. You can force it to use Builder instead with the +:type+ option:

<ruby>
render :inline =>
  "xml.p {'Horrid coding practice!'}", :type => :builder
</ruby>

h5. Rendering Text

You can send plain text - with no markup at all - back to the browser by using the +:text+ option to +render+:

<ruby>
render :text => "OK"
</ruby>

TIP: Rendering pure text is most useful when you're responding to AJAX or web service requests that are expecting something other than proper HTML.

NOTE: By default, if you use the +:text+ option, the text is rendered without using the current layout. If you want Rails to put the text into the current layout, you need to add the +:layout => true+ option.

h5. Rendering JSON

JSON is a JavaScript data format used by many AJAX libraries. Rails has built-in support for converting objects to JSON and rendering that JSON back to the browser:

<ruby>
render :json => @product
</ruby>

TIP: You don't need to call +to_json+ on the object that you want to render. If you use the +:json+ option, +render+ will automatically call +to_json+ for you.

h5. Rendering XML

Rails also has built-in support for converting objects to XML and rendering that XML back to the caller:

<ruby>
render :xml => @product
</ruby>

TIP: You don't need to call +to_xml+ on the object that you want to render. If you use the +:xml+ option, +render+ will automatically call +to_xml+ for you.

h5. Rendering Vanilla JavaScript

Rails can render vanilla JavaScript:

<ruby>
render :js => "alert('Hello Rails');"
</ruby>

This will send the supplied string to the browser with a MIME type of +text/javascript+.

h5. Options for +render+

Calls to the +render+ method generally accept four options:

* +:content_type+
* +:layout+
* +:status+
* +:location+

h6. The +:content_type+ Option

By default, Rails will serve the results of a rendering operation with the MIME content-type of +text/html+ (or +application/json+ if you use the +:json+ option, or +application/xml+ for the +:xml+ option.). There are times when you might like to change this, and you can do so by setting the +:content_type+ option:

<ruby>
render :file => filename, :content_type => "application/rss"
</ruby>

h6. The +:layout+ Option

With most of the options to +render+, the rendered content is displayed as part of the current layout. You'll learn more about layouts and how to use them later in this guide.

You can use the +:layout+ option to tell Rails to use a specific file as the layout for the current action:

<ruby>
render :layout => "special_layout"
</ruby>

You can also tell Rails to render with no layout at all:

<ruby>
render :layout => false
</ruby>

h6. The +:status+ Option

Rails will automatically generate a response with the correct HTTP status code (in most cases, this is +200 OK+). You can use the +:status+ option to change this:

<ruby>
render :status => 500
render :status => :forbidden
</ruby>

Rails understands both numeric and symbolic status codes.

h6. The +:location+ Option

You can use the +:location+ option to set the HTTP +Location+ header:

<ruby>
render :xml => photo, :location => photo_url(photo)
</ruby>

h5. Finding Layouts

To find the current layout, Rails first looks for a file in +app/views/layouts+ with the same base name as the controller. For example, rendering actions from the +PhotosController+ class will use +app/views/layouts/photos.html.erb+ (or +app/views/layouts/photos.builder+). If there is no such controller-specific layout, Rails will use +app/views/layouts/application.html.erb+ or +app/views/layouts/application.builder+. If there is no +.erb+ layout, Rails will use a +.builder+ layout if one exists. Rails also provides several ways to more precisely assign specific layouts to individual controllers and actions.

h6. Specifying Layouts for Controllers

You can override the default layout conventions in your controllers by using the +layout+ declaration. For example:

<ruby>
class ProductsController < ApplicationController
  layout "inventory"
  #...
end
</ruby>

With this declaration, all of the views rendered by the products controller will use +app/views/layouts/inventory.html.erb+ as their layout.

To assign a specific layout for the entire application, use a +layout+ declaration in your +ApplicationController+ class:

<ruby>
class ApplicationController < ActionController::Base
  layout "main"
  #...
end
</ruby>

With this declaration, all of the views in the entire application will use +app/views/layouts/main.html.erb+ for their layout.

h6. Choosing Layouts at Runtime

You can use a symbol to defer the choice of layout until a request is processed:

<ruby>
class ProductsController < ApplicationController
  layout "products_layout"

  def show
    @product = Product.find(params[:id])
  end

  private
    def products_layout
      @current_user.special? ? "special" : "products"
    end

end
</ruby>

Now, if the current user is a special user, they'll get a special layout when viewing a product.

You can even use an inline method, such as a Proc, to determine the layout. For example, if you pass a Proc object, the block you give the Proc will be given the +controller+ instance, so the layout can be determined based on the current request:

<ruby>
class ProductsController < ApplicationController
  layout Proc.new { |controller| controller.request.xhr? ? "popup" : "application" }
end
</ruby>

h6. Conditional Layouts

Layouts specified at the controller level support the +:only+ and +:except+ options. These options take either a method name, or an array of method names, corresponding to method names within the controller:

<ruby>
class ProductsController < ApplicationController
  layout "product", :except => [:index, :rss]
end
</ruby>

With this declaration, the +product+ layout would be used for everything but the +rss+ and +index+ methods.

h6. Layout Inheritance

Layout declarations cascade downward in the hierarchy, and more specific layout declarations always override more general ones. For example:

* +application_controller.rb+

<ruby>
class ApplicationController < ActionController::Base
  layout "main"
end
</ruby>

* +posts_controller.rb+

<ruby>
class PostsController < ApplicationController
end
</ruby>

* +special_posts_controller.rb+

<ruby>
class SpecialPostsController < PostsController
  layout "special"
end
</ruby>

* +old_posts_controller.rb+

<ruby>
class OldPostsController < SpecialPostsController
  layout false

  def show
    @post = Post.find(params[:id])
  end

  def index
    @old_posts = Post.older
    render :layout => "old"
  end
  # ...
end
</ruby>

In this application:

* In general, views will be rendered in the +main+ layout
* +PostsController#index+ will use the +main+ layout
* +SpecialPostsController#index+ will use the +special+ layout
* +OldPostsController#show+ will use no layout at all
* +OldPostsController#index+ will use the +old+ layout

h5. Avoiding Double Render Errors

Sooner or later, most Rails developers will see the error message "Can only render or redirect once per action". While this is annoying, it's relatively easy to fix. Usually it happens because of a fundamental misunderstanding of the way that +render+ works.

For example, here's some code that will trigger this error:

<ruby>
def show
  @book = Book.find(params[:id])
  if @book.special?
    render :action => "special_show"
  end
  render :action => "regular_show"
end
</ruby>

If +@book.special?+ evaluates to +true+, Rails will start the rendering process to dump the +@book+ variable into the +special_show+ view. But this will _not_ stop the rest of the code in the +show+ action from running, and when Rails hits the end of the action, it will start to render the +regular_show+ view - and throw an error. The solution is simple: make sure that you have only one call to +render+ or +redirect+ in a single code path. One thing that can help is +and return+. Here's a patched version of the method:

<ruby>
def show
  @book = Book.find(params[:id])
  if @book.special?
    render :action => "special_show" and return
  end
  render :action => "regular_show"
end
</ruby>

Make sure to use +and return+ instead of +&amp;&amp; return+ because +&amp;&amp; return+ will not work due to the operator precedence in the Ruby Language.

Note that the implicit render done by ActionController detects if +render+ has been called, so the following will work without errors:

<ruby>
def show
  @book = Book.find(params[:id])
  if @book.special?
    render :action => "special_show"
  end
end
</ruby>

This will render a book with +special?+ set with the +special_show+ template, while other books will render with the default +show+ template.

h4. Using +redirect_to+

Another way to handle returning responses to an HTTP request is with +redirect_to+. As you've seen, +render+ tells Rails which view (or other asset) to use in constructing a response. The +redirect_to+ method does something completely different: it tells the browser to send a new request for a different URL. For example, you could redirect from wherever you are in your code to the index of photos in your application with this call:

<ruby>
redirect_to photos_url
</ruby>

You can use +redirect_to+ with any arguments that you could use with +link_to+ or +url_for+. There's also a special redirect that sends the user back to the page they just came from:

<ruby>
redirect_to :back
</ruby>

h5. Getting a Different Redirect Status Code

Rails uses HTTP status code 302, a temporary redirect, when you call +redirect_to+. If you'd like to use a different status code, perhaps 301, a permanent redirect, you can use the +:status+ option:

<ruby>
redirect_to photos_path, :status => 301
</ruby>

Just like the +:status+ option for +render+, +:status+ for +redirect_to+ accepts both numeric and symbolic header designations.

h5. The Difference Between +render+ and +redirect_to+

Sometimes inexperienced developers think of +redirect_to+ as a sort of +goto+ command, moving execution from one place to another in your Rails code. This is _not_ correct. Your code stops running and waits for a new request for the browser. It just happens that you've told the browser what request it should make next, by sending back an HTTP 302 status code.

Consider these actions to see the difference:

<ruby>
def index
  @books = Book.all
end

def show
  @book = Book.find_by_id(params[:id])
  if @book.nil?
    render :action => "index"
  end
end
</ruby>

With the code in this form, there will likely be a problem if the +@book+ variable is +nil+. Remember, a +render :action+ doesn't run any code in the target action, so nothing will set up the +@books+ variable that the +index+ view will probably require. One way to fix this is to redirect instead of rendering:

<ruby>
def index
  @books = Book.all
end

def show
  @book = Book.find_by_id(params[:id])
  if @book.nil?
    redirect_to :action => :index
  end
end
</ruby>

With this code, the browser will make a fresh request for the index page, the code in the +index+ method will run, and all will be well.

The only downside to this code is that it requires a round trip to the browser: the browser requested the show action with +/books/1+ and the controller finds that there are no books, so the controller sends out a 302 redirect response to the browser telling it to go to +/books/+, the browser complies and sends a new request back to the controller asking now for the +index+ action, the controller then gets all the books in the database and renders the index template, sending it back down to the browser which then shows it on your screen.

While in a small application, this added latency might not be a problem, it is something to think about if response time is a concern. We can demonstrate one way to handle this with a contrived example:

<ruby>
def index
  @books = Book.all
end

def show
  @book = Book.find_by_id(params[:id])
  if @book.nil?
    @books = Book.all
    render "index", :alert => "Your book was not found!"
  end
end
</ruby>

This would detect that there are no books with the specified ID, populate the +@books+ instance variable with all the books in the model, and then directly render the +index.html.erb+ template, returning it to the browser with a flash alert message to tell the user what happened.

h4. Using +head+ To Build Header-Only Responses

The +head+ method can be used to send responses with only headers to the browser. It provides a more obvious alternative to calling +render :nothing+. The +head+ method takes one parameter, which is interpreted as a hash of header names and values. For example, you can return only an error header:

<ruby>
head :bad_request
</ruby>

This would produce the following header:

<shell>
HTTP/1.1 400 Bad Request
Connection: close
Date: Sun, 24 Jan 2010 12:15:53 GMT
Transfer-Encoding: chunked
Content-Type: text/html; charset=utf-8
X-Runtime: 0.013483
Set-Cookie: _blog_session=...snip...; path=/; HttpOnly
Cache-Control: no-cache
</shell>

Or you can use other HTTP headers to convey other information:

<ruby>
head :created, :location => photo_path(@photo)
</ruby>

Which would produce:

<shell>
HTTP/1.1 201 Created
Connection: close
Date: Sun, 24 Jan 2010 12:16:44 GMT
Transfer-Encoding: chunked
Location: /photos/1
Content-Type: text/html; charset=utf-8
X-Runtime: 0.083496
Set-Cookie: _blog_session=...snip...; path=/; HttpOnly
Cache-Control: no-cache
</shell>

h3. Structuring Layouts

When Rails renders a view as a response, it does so by combining the view with the current layout, using the rules for finding the current layout that were covered earlier in this guide. Within a layout, you have access to three tools for combining different bits of output to form the overall response:

* Asset tags
* +yield+ and +content_for+
* Partials

h4. Asset Tag Helpers

Asset tag helpers provide methods for generating HTML that link views to feeds, JavaScript, stylesheets, images, videos and audios. There are six asset tag helpers available in Rails:

* +auto_discovery_link_tag+
* +javascript_include_tag+
* +stylesheet_link_tag+
* +image_tag+
* +video_tag+
* +audio_tag+

You can use these tags in layouts or other views, although the +auto_discovery_link_tag+, +javascript_include_tag+, and +stylesheet_link_tag+, are most commonly used in the +&lt;head&gt;+ section of a layout.

WARNING: The asset tag helpers do _not_ verify the existence of the assets at the specified locations; they simply assume that you know what you're doing and generate the link.

h5. Linking to Feeds with the +auto_discovery_link_tag+

The +auto_discovery_link_tag+ helper builds HTML that most browsers and newsreaders can use to detect the presence of RSS or Atom feeds. It takes the type of the link (+:rss+ or +:atom+), a hash of options that are passed through to url_for, and a hash of options for the tag:

<erb>
<%= auto_discovery_link_tag(:rss, {:action => "feed"},
  {:title => "RSS Feed"}) %>
</erb>

There are three tag options available for the +auto_discovery_link_tag+:

* +:rel+ specifies the +rel+ value in the link. The default value is "alternate".
* +:type+ specifies an explicit MIME type. Rails will generate an appropriate MIME type automatically.
* +:title+ specifies the title of the link. The default value is the uppercased +:type+ value, for example, "ATOM" or "RSS".

h5. Linking to JavaScript Files with the +javascript_include_tag+

The +javascript_include_tag+ helper returns an HTML +script+ tag for each source provided.

If you are using Rails with the "Asset Pipeline":asset_pipeline.html enabled, this helper will generate a link to +/assets/javascripts/+ rather than +public/javascripts+ which was used in earlier versions of Rails. This link is then served by the Sprockets gem, which was introduced in Rails 3.1.

A JavaScript file within a Rails application or Rails engine goes in one of three locations: +app/assets+, +lib/assets+ or +vendor/assets+. These locations are explained in detail in the "Asset Organization section in the Asset Pipeline Guide":asset_pipeline.html#asset-organization

You can specify a full path relative to the document root, or a URL, if you prefer. For example, to link to a JavaScript file that is inside a directory called +javascripts+ inside of one of +app/assets+, +lib/assets+ or +vendor/assets+, you would do this:

<erb>
<%= javascript_include_tag "main" %>
</erb>

Rails will then output a +script+ tag such as this:

<html>
<script src='/assets/main.js'></script>
</html>

The request to this asset is then served by the Sprockets gem.

To include multiple files such as +app/assets/javascripts/main.js+ and +app/assets/javascripts/columns.js+ at the same time:

<erb>
<%= javascript_include_tag "main", "columns" %>
</erb>

To include +app/assets/javascripts/main.js+ and +app/assets/javascripts/photos/columns.js+:

<erb>
<%= javascript_include_tag "main", "/photos/columns" %>
</erb>

To include +http://example.com/main.js+:

<erb>
<%= javascript_include_tag "http://example.com/main.js" %>
</erb>

If the application does not use the asset pipeline, the +:defaults+ option loads jQuery by default:

<erb>
<%= javascript_include_tag :defaults %>
</erb>

Outputting +script+ tags such as this:

<html>
<script src="/javascripts/jquery.js"></script>
<script src="/javascripts/jquery_ujs.js"></script>
</html>

These two files for jQuery, +jquery.js+ and +jquery_ujs.js+ must be placed inside +public/javascripts+ if the application doesn't use the asset pipeline. These files can be downloaded from the "jquery-rails repository on GitHub":https://github.com/indirect/jquery-rails/tree/master/vendor/assets/javascripts

WARNING: If you are using the asset pipeline, this tag will render a +script+ tag for an asset called +defaults.js+, which would not exist in your application unless you've explicitly created it.

And you can in any case override the +:defaults+ expansion in <tt>config/application.rb</tt>:

<ruby>
config.action_view.javascript_expansions[:defaults] = %w(foo.js bar.js)
</ruby>

You can also define new defaults:

<ruby>
config.action_view.javascript_expansions[:projects] = %w(projects.js tickets.js)
</ruby>

And use them by referencing them exactly like +:defaults+:

<erb>
<%= javascript_include_tag :projects %>
</erb>

When using <tt>:defaults</tt>, if an <tt>application.js</tt> file exists in <tt>public/javascripts</tt> it will be included as well at the end.

Also, if the asset pipeline is disabled, the +:all+ expansion loads every JavaScript file in +public/javascripts+:

<erb>
<%= javascript_include_tag :all %>
</erb>

Note that your defaults of choice will be included first, so they will be available to all subsequently included files.

You can supply the +:recursive+ option to load files in subfolders of +public/javascripts+ as well:

<erb>
<%= javascript_include_tag :all, :recursive => true %>
</erb>

If you're loading multiple JavaScript files, you can create a better user experience by combining multiple files into a single download. To make this happen in production, specify +:cache => true+ in your +javascript_include_tag+:

<erb>
<%= javascript_include_tag "main", "columns", :cache => true %>
</erb>

By default, the combined file will be delivered as +javascripts/all.js+. You can specify a location for the cached asset file instead:

<erb>
<%= javascript_include_tag "main", "columns",
  :cache => "cache/main/display" %>
</erb>

You can even use dynamic paths such as +cache/#{current_site}/main/display+.

h5. Linking to CSS Files with the +stylesheet_link_tag+

The +stylesheet_link_tag+ helper returns an HTML +&lt;link&gt;+ tag for each source provided.

If you are using Rails with the "Asset Pipeline" enabled, this helper will generate a link to +/assets/stylesheets/+. This link is then processed by the Sprockets gem. A stylesheet file can be stored in one of three locations: +app/assets+, +lib/assets+ or +vendor/assets+.

You can specify a full path relative to the document root, or a URL. For example, to link to a stylesheet file that is inside a directory called +stylesheets+ inside of one of +app/assets+, +lib/assets+ or +vendor/assets+, you would do this:

<erb>
<%= stylesheet_link_tag "main" %>
</erb>

To include +app/assets/stylesheets/main.css+ and +app/assets/stylesheets/columns.css+:

<erb>
<%= stylesheet_link_tag "main", "columns" %>
</erb>

To include +app/assets/stylesheets/main.css+ and +app/assets/stylesheets/photos/columns.css+:

<erb>
<%= stylesheet_link_tag "main", "/photos/columns" %>
</erb>

To include +http://example.com/main.css+:

<erb>
<%= stylesheet_link_tag "http://example.com/main.css" %>
</erb>

By default, the +stylesheet_link_tag+ creates links with +media="screen" rel="stylesheet"+. You can override any of these defaults by specifying an appropriate option (+:media+, +:rel+):

<erb>
<%= stylesheet_link_tag "main_print", :media => "print" %>
</erb>

If the asset pipeline is disabled, the +all+ option links every CSS file in +public/stylesheets+:

<erb>
<%= stylesheet_link_tag :all %>
</erb>

You can supply the +:recursive+ option to link files in subfolders of +public/stylesheets+ as well:

<erb>
<%= stylesheet_link_tag :all, :recursive => true %>
</erb>

If you're loading multiple CSS files, you can create a better user experience by combining multiple files into a single download. To make this happen in production, specify +:cache => true+ in your +stylesheet_link_tag+:

<erb>
<%= stylesheet_link_tag "main", "columns", :cache => true %>
</erb>

By default, the combined file will be delivered as +stylesheets/all.css+. You can specify a location for the cached asset file instead:

<erb>
<%= stylesheet_link_tag "main", "columns",
  :cache => "cache/main/display" %>
</erb>

You can even use dynamic paths such as +cache/#{current_site}/main/display+.

h5. Linking to Images with the +image_tag+

The +image_tag+ helper builds an HTML +&lt;img /&gt;+ tag to the specified file. By default, files are loaded from +public/images+.

WARNING: Note that you must specify the extension of the image. Previous versions of Rails would allow you to just use the image name and would append +.png+ if no extension was given but Rails 3.0 does not.

<erb>
<%= image_tag "header.png" %>
</erb>

You can supply a path to the image if you like:

<erb>
<%= image_tag "icons/delete.gif" %>
</erb>

You can supply a hash of additional HTML options:

<erb>
<%= image_tag "icons/delete.gif", {:height => 45} %>
</erb>

You can also supply an alternate image to show on mouseover:

<erb>
<%= image_tag "home.gif", :onmouseover => "menu/home_highlight.gif" %>
</erb>

You can supply alternate text for the image which will be used if the user has images turned off in their browser. If you do not specify an alt text explicitly, it defaults to the file name of the file, capitalized and with no extension. For example, these two image tags would return the same code:

<erb>
<%= image_tag "home.gif" %>
<%= image_tag "home.gif", :alt => "Home" %>
</erb>

You can also specify a special size tag, in the format "{width}x{height}":

<erb>
<%= image_tag "home.gif", :size => "50x20" %>
</erb>

In addition to the above special tags, you can supply a final hash of standard HTML options, such as +:class+, +:id+ or +:name+:

<erb>
<%= image_tag "home.gif", :alt => "Go Home",
                          :id => "HomeImage",
                          :class => "nav_bar" %>
</erb>

h5. Linking to Videos with the +video_tag+

The +video_tag+ helper builds an HTML 5 +&lt;video&gt;+ tag to the specified file. By default, files are loaded from +public/videos+.

<erb>
<%= video_tag "movie.ogg" %>
</erb>

Produces

<erb>
<video src="/videos/movie.ogg" />
</erb>

Like an +image_tag+ you can supply a path, either absolute, or relative to the +public/videos+ directory. Additionally you can specify the +:size => "#{width}x#{height}"+ option just like an +image_tag+. Video tags can also have any of the HTML options specified at the end (+id+, +class+ et al).

The video tag also supports all of the +&lt;video&gt;+ HTML options through the HTML options hash, including:

* +:poster => "image_name.png"+, provides an image to put in place of the video before it starts playing.
* +:autoplay => true+, starts playing the video on page load.
* +:loop => true+, loops the video once it gets to the end.
* +:controls => true+, provides browser supplied controls for the user to interact with the video.
* +:autobuffer => true+, the video will pre load the file for the user on page load.

You can also specify multiple videos to play by passing an array of videos to the +video_tag+:

<erb>
<%= video_tag ["trailer.ogg", "movie.ogg"] %>
</erb>

This will produce:

<erb>
<video><source src="trailer.ogg" /><source src="movie.ogg" /></video>
</erb>

h5. Linking to Audio Files with the +audio_tag+

The +audio_tag+ helper builds an HTML 5 +&lt;audio&gt;+ tag to the specified file. By default, files are loaded from +public/audios+.

<erb>
<%= audio_tag "music.mp3" %>
</erb>

You can supply a path to the audio file if you like:

<erb>
<%= audio_tag "music/first_song.mp3" %>
</erb>

You can also supply a hash of additional options, such as +:id+, +:class+ etc.

Like the +video_tag+, the +audio_tag+ has special options:

* +:autoplay => true+, starts playing the audio on page load
* +:controls => true+, provides browser supplied controls for the user to interact with the audio.
* +:autobuffer => true+, the audio will pre load the file for the user on page load.

h4. Understanding +yield+

Within the context of a layout, +yield+ identifies a section where content from the view should be inserted. The simplest way to use this is to have a single +yield+, into which the entire contents of the view currently being rendered is inserted:

<erb>
<html>
  <head>
  </head>
  <body>
  <%= yield %>
  </body>
</html>
</erb>

You can also create a layout with multiple yielding regions:

<erb>
<html>
  <head>
  <%= yield :head %>
  </head>
  <body>
  <%= yield %>
  </body>
</html>
</erb>

The main body of the view will always render into the unnamed +yield+. To render content into a named +yield+, you use the +content_for+ method.

h4. Using the +content_for+ Method

The +content_for+ method allows you to insert content into a named +yield+ block in your layout. For example, this view would work with the layout that you just saw:

<erb>
<% content_for :head do %>
  <title>A simple page</title>
<% end %>

<p>Hello, Rails!</p>
</erb>

The result of rendering this page into the supplied layout would be this HTML:

<erb>
<html>
  <head>
  <title>A simple page</title>
  </head>
  <body>
  <p>Hello, Rails!</p>
  </body>
</html>
</erb>

The +content_for+ method is very helpful when your layout contains distinct regions such as sidebars and footers that should get their own blocks of content inserted. It's also useful for inserting tags that load page-specific JavaScript or css files into the header of an otherwise generic layout.

h4. Using Partials

Partial templates - usually just called "partials" - are another device for breaking the rendering process into more manageable chunks. With a partial, you can move the code for rendering a particular piece of a response to its own file.

h5. Naming Partials

To render a partial as part of a view, you use the +render+ method within the view:

<ruby>
<%= render "menu" %>
</ruby>

This will render a file named +_menu.html.erb+ at that point within the view being rendered. Note the leading underscore character: partials are named with a leading underscore to distinguish them from regular views, even though they are referred to without the underscore. This holds true even when you're pulling in a partial from another folder:

<ruby>
<%= render "shared/menu" %>
</ruby>

That code will pull in the partial from +app/views/shared/_menu.html.erb+.

h5. Using Partials to Simplify Views

One way to use partials is to treat them as the equivalent of subroutines: as a way to move details out of a view so that you can grasp what's going on more easily. For example, you might have a view that looked like this:

<erb>
<%= render "shared/ad_banner" %>

<h1>Products</h1>

<p>Here are a few of our fine products:</p>
...

<%= render "shared/footer" %>
</erb>

Here, the +_ad_banner.html.erb+ and +_footer.html.erb+ partials could contain content that is shared among many pages in your application. You don't need to see the details of these sections when you're concentrating on a particular page.

TIP: For content that is shared among all pages in your application, you can use partials directly from layouts.

h5. Partial Layouts

A partial can use its own layout file, just as a view can use a layout. For example, you might call a partial like this:

<erb>
<%= render :partial => "link_area", :layout => "graybar" %>
</erb>

This would look for a partial named +_link_area.html.erb+ and render it using the layout +_graybar.html.erb+. Note that layouts for partials follow the same leading-underscore naming as regular partials, and are placed in the same folder with the partial that they belong to (not in the master +layouts+ folder).

Also note that explicitly specifying +:partial+ is required when passing additional options such as +:layout+.

h5. Passing Local Variables

You can also pass local variables into partials, making them even more powerful and flexible. For example, you can use this technique to reduce duplication between new and edit pages, while still keeping a bit of distinct content:

* +new.html.erb+

<erb>
<h1>New zone</h1>
<%= error_messages_for :zone %>
<%= render :partial => "form", :locals => { :zone => @zone } %>
</erb>

* +edit.html.erb+

<erb>
<h1>Editing zone</h1>
<%= error_messages_for :zone %>
<%= render :partial => "form", :locals => { :zone => @zone } %>
</erb>

* +_form.html.erb+

<erb>
<%= form_for(zone) do |f| %>
  <p>
    <b>Zone name</b><br />
    <%= f.text_field :name %>
  </p>
  <p>
    <%= f.submit %>
  </p>
<% end %>
</erb>

Although the same partial will be rendered into both views, Action View's submit helper will return "Create Zone" for the new action and "Update Zone" for the edit action.

Every partial also has a local variable with the same name as the partial (minus the underscore). You can pass an object in to this local variable via the +:object+ option:

<erb>
<%= render :partial => "customer", :object => @new_customer %>
</erb>

Within the +customer+ partial, the +customer+ variable will refer to +@new_customer+ from the parent view.

WARNING: In previous versions of Rails, the default local variable would look for an instance variable with the same name as the partial in the parent. This behavior was deprecated in 2.3 and has been removed in Rails 3.0.

If you have an instance of a model to render into a partial, you can use a shorthand syntax:

<erb>
<%= render @customer %>
</erb>

Assuming that the +@customer+ instance variable contains an instance of the +Customer+ model, this will use +_customer.html.erb+ to render it and will pass the local variable +customer+ into the partial which will refer to the +@customer+ instance variable in the parent view.

h5. Rendering Collections

Partials are very useful in rendering collections. When you pass a collection to a partial via the +:collection+ option, the partial will be inserted once for each member in the collection:

* +index.html.erb+

<erb>
<h1>Products</h1>
<%= render :partial => "product", :collection => @products %>
</erb>

* +_product.html.erb+

<erb>
<p>Product Name: <%= product.name %></p>
</erb>

When a partial is called with a pluralized collection, then the individual instances of the partial have access to the member of the collection being rendered via a variable named after the partial. In this case, the partial is +_product+, and within the +_product+ partial, you can refer to +product+ to get the instance that is being rendered.

In Rails 3.0, there is also a shorthand for this. Assuming +@products+ is a collection of +product+ instances, you can simply write this in the +index.html.erb+ to produce the same result:

<erb>
<h1>Products</h1>
<%= render @products %>
</erb>

Rails determines the name of the partial to use by looking at the model name in the collection. In fact, you can even create a heterogeneous collection and render it this way, and Rails will choose the proper partial for each member of the collection:

* +index.html.erb+

<erb>
<h1>Contacts</h1>
<%= render [customer1, employee1, customer2, employee2] %>
</erb>

* +customers/_customer.html.erb+

<erb>
<p>Customer: <%= customer.name %></p>
</erb>

* +employees/_employee.html.erb+

<erb>
<p>Employee: <%= employee.name %></p>
</erb>

In this case, Rails will use the customer or employee partials as appropriate for each member of the collection.

In the event that the collection is empty, +render+ will return nil, so it should be fairly simple to provide alternative content.

<erb>
<h1>Products</h1>
<%= render(@products) || "There are no products available." %>
</erb>

h5. Local Variables

To use a custom local variable name within the partial, specify the +:as+ option in the call to the partial:

<erb>
<%= render :partial => "product", :collection => @products, :as => :item %>
</erb>

With this change, you can access an instance of the +@products+ collection as the +item+ local variable within the partial.

You can also pass in arbitrary local variables to any partial you are rendering with the +:locals => {}+ option:

<erb>
<%= render :partial => "products", :collection => @products,
           :as => :item, :locals => {:title => "Products Page"} %>
</erb>

Would render a partial +_products.html.erb+ once for each instance of +product+ in the +@products+ instance variable passing the instance to the partial as a local variable called +item+ and to each partial, make the local variable +title+ available with the value +Products Page+.

TIP: Rails also makes a counter variable available within a partial called by the collection, named after the member of the collection followed by +_counter+. For example, if you're rendering +@products+, within the partial you can refer to +product_counter+ to tell you how many times the partial has been rendered. This does not work in conjunction with the +:as => :value+ option.

You can also specify a second partial to be rendered between instances of the main partial by using the +:spacer_template+ option:

h5. Spacer Templates

<erb>
<%= render :partial => @products, :spacer_template => "product_ruler" %>
</erb>

Rails will render the +_product_ruler+ partial (with no data passed in to it) between each pair of +_product+ partials.

h5. Partial Layouts

When rendering collections it is also possible to use the +:layout+ option:

<erb>
<%= render :partial => "product", :collection => @products, :layout => "special_layout" %>
</erb>

The layout will be rendered together with the partial for each item in the collection. The current object and object_counter variables will be available in the layout as well, the same way they do within the partial.

h4. Using Nested Layouts

You may find that your application requires a layout that differs slightly from your regular application layout to support one particular controller. Rather than repeating the main layout and editing it, you can accomplish this by using nested layouts (sometimes called sub-templates). Here's an example:

Suppose you have the following +ApplicationController+ layout:

* +app/views/layouts/application.html.erb+

<erb>
<html>
<head>
  <title><%= @page_title or "Page Title" %></title>
  <%= stylesheet_link_tag "layout" %>
  <style><%= yield :stylesheets %></style>
</head>
<body>
  <div id="top_menu">Top menu items here</div>
  <div id="menu">Menu items here</div>
  <div id="content"><%= content_for?(:content) ? yield(:content) : yield %></div>
</body>
</html>
</erb>

On pages generated by +NewsController+, you want to hide the top menu and add a right menu:

* +app/views/layouts/news.html.erb+

<erb>
<% content_for :stylesheets do %>
  #top_menu {display: none}
  #right_menu {float: right; background-color: yellow; color: black}
<% end %>
<% content_for :content do %>
  <div id="right_menu">Right menu items here</div>
  <%= content_for?(:news_content) ? yield(:news_content) : yield %>
<% end %>
<%= render :template => "layouts/application" %>
</erb>

That's it. The News views will use the new layout, hiding the top menu and adding a new right menu inside the "content" div.

There are several ways of getting similar results with different sub-templating schemes using this technique. Note that there is no limit in nesting levels. One can use the +ActionView::render+ method via +render :template => 'layouts/news'+ to base a new layout on the News layout. If you are sure you will not subtemplate the +News+ layout, you can replace the +content_for?(:news_content) ? yield(:news_content) : yield+ with simply +yield+.
